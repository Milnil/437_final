<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video and Audio Stream</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #333;
            color: #fff;
            font-family: Arial, sans-serif;
        }

        #video-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #videoCanvas {
            width: 640px;
            height: 480px;
            background-color: black;
        }
    </style>
</head>

<body>

    <div id="video-container">
        <h1>Live Stream</h1>
        <canvas id="videoCanvas"></canvas>
        <div id="status">Connecting...</div>
    </div>

    <script>
        const canvas = document.getElementById('videoCanvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();

        class StreamClient {
            constructor() {
                this.connect();
                this.setupAudio();
            }

            connect() {
                this.socket = new WebSocket('ws://192.168.10.59:4400');
                this.socket.binaryType = 'arraybuffer';

                this.socket.onopen = () => {
                    statusDiv.textContent = 'Connected';
                };

                this.socket.onmessage = async (event) => {
                    const data = new Uint8Array(event.data);
                    const type = data[0];
                    const content = data.slice(4); // Skip header

                    if (type === 1) { // Video
                        const blob = new Blob([content], { type: 'image/jpeg' });
                        const imageBitmap = await createImageBitmap(blob);
                        ctx.drawImage(imageBitmap, 0, 0, canvas.width, canvas.height);
                    } else if (type === 2) { // Audio
                        this.playAudio(content);
                    }
                };

                this.socket.onclose = () => {
                    statusDiv.textContent = 'Disconnected - Reconnecting...';
                    setTimeout(() => this.connect(), 1000);
                };

                this.socket.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusDiv.textContent = 'Connection error';
                };
            }

            setupAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }

            async playAudio(audioData) {
                try {
                    const audioBuffer = await this.audioContext.decodeAudioData(audioData.buffer);
                    const source = this.audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(this.audioContext.destination);
                    source.start(0);
                } catch (error) {
                    console.error('Audio playback error:', error);
                }
            }
        }

        // Start the client
        const client = new StreamClient();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (client.socket && client.socket.readyState === WebSocket.OPEN) {
                client.socket.close();
            }
        });
    </script>

</body>

</html>